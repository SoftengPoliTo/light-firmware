# Code Quality + Manifest Producer

https://github.com/user-attachments/assets/6cc4fffb-1144-4ba3-80c0-861fff586fde

## Description:

**1. Set up job**: This step is automatic and is performed at the start of every GitHub Actions job. Here, GitHub sets up a clean environment in an Ubuntu virtual machine (`ubuntu-latest`), preparing the environment for subsequent operations. It includes runner setup, resource allocation, mounting temporary disks and network setup. It does not contain customised logic, but is essential to ensure a standardised environment.

**2. Run actions/checkout@v4**: This action serves to clone the current repository within the runner's environment, making all project files available for the next steps. It is a standard step in GitHub ICs, and allows future commands to access the source code and scripts included in the repository.

**3. Install system dependencies**: In this step, system tools necessary for the execution of the pipeline are installed, which are essential for ensuring the portability of the binary and for some subsequent analysis.

**4. Install Rust toolchain**: The Rust toolchain is installed here, using the action dtolnay/rust-toolchain@stable. The target `x86_64-unknown-linux-musl` is specified in order to compile a statically linked binary. This is a prerequisite for the subsequent analysis of the `light-firmware` by the `manifest-producer` tool.

**5. Install rust-code-analysis**: The video demonstrates the automated integration of the `rust-code-analysis` tool into the CI pipeline. The analysis starts with the installation of the tool from the official GitHub repository. It is downloaded, extracted and added to the PATH for use in the following steps.

**6. Initialize artifacts directory**: A directory structure (step1, step2, step3) is created within the final-artifacts folder, in which all subsequent analysis results will be stored. This allows the data to be organised in an orderly manner for each CI step.

**7. Run rust-code-analysis**: The rust-code-analysis-cli tool is run to analyse the firmware source code. The data is saved in JSON format, ready to be processed. The output includes metrics such as LOC, cyclomatic complexity and maintainability index.

**8. Evaluate code quality**: A Python script processes the generated JSON and calculates quality indicators for each function, such as Lines of Code (LOC), Cyclomatic Complexity, Maintainability Index, and Halstead Effort.
The result is a visual traffic light report for each function: 游릭 (good), 游리 (attention), 游댮 (critical). This enables rapid identification of problem areas in the code.

**9. Collect Step 1 artifacts**: All data generated by the quality analysis (JSON output + report) are copied into `final-artifacts/step1/`. This step **preserves the intermediate results**, which will be included in the final downloadable package.

**10. Run anomaly Detection**: 

**11. Build firmware statically with musl**: Static firmware compilation using cargo build with target x86_64-unknown-linux-musl. This step is crucial because the manifest-producer tool requires a statically linked ELF binary for further analysis.

**12. Download and setup manifest-producer**: The manifest-producer tool is downloaded and configured, allowing the generated binary to be analysed. The tool is made executable and is ready for structural and behavioural analysis of the firmware.

**13. Run manifest-producer analysis**: The tool analyses the ELF file to assess file integrity, internal structure (class, endianness, ELF header), active protections (NX, RELRO, PIE, etc.), and presence of debug symbols or suspicious sections. The second phase involves reading the binary, disassembling, analysing the system calls, and constructing the call graph of the main function. The result is exported to JSON and HTML.

**14. Run final compliance analysis**: Execution of a Python script that consolidates the results of the three previous analyses (code quality, anomaly detection, manifest-producer). Each section receives a status light based on the results: (游댮) **criticality present**, (游리) **warnings to be checked**, and (游릭) **all OK**. The final report (`FINAL_REPORT.md`) includes detailed messages for each stage, recommendations and a summary of the firmware's level of compliance.

**15. Upload analysis results**: All results are uploaded to the `final-artifacts/` folder as GitHub artefacts, so that they can be downloaded by users or automated systems. This includes JSON, textual reports and final reports.

**16. Post run actions/checkout@v4**: Automatic clean-up step performed by GitHub. It finishes the checkout action, removes temporary files, unmounts the repo and closes the job in an orderly manner. It does not contain project-specific logic.
